---
description: TypeScript code style and optimization guidelines
globs: *.ts,*.tsx,*.mts
alwaysApply: false
---

# TypeScript Code Style Guide

## Types and Type Safety

- avoid explicit type annotations when TypeScript can infer types.
- avoid implicitly `any` variables; explicitly type when necessary (e.g., `let a: number` instead of `let a`).
- use the most accurate type possible (e.g., prefer `Record<PropertyKey, unknown>` over `object`).
- prefer `interface` over `type` for object shapes (e.g., React component props). Keep `type` for unions, intersections, and utility types.
- prefer `as const satisfies XyzInterface` over plain `as const` when suitable.
- prefer `@ts-expect-error` over `@ts-ignore`
- prefer `Record<string, any>` over `any`

- **Avoid unnecessary null checks**: Before adding `xxx !== null`, `?.`, `??`, or `!.`, read the type definition to confirm the necessary. **Example:**

  ```typescript
  // ❌ Wrong: budget.spend and budget.maxBudget is number, not number | null
  if (budget.spend !== null && budget.maxBudget !== null && budget.spend >= budget.maxBudget) {
    // ...
  }

  // ✅ Right
  if (budget.spend >= budget.maxBudget) {
    // ...
  }
  ```

- **Avoid redundant runtime checks**: Don't add runtime validation for conditions already guaranteed by types or previous checks. Trust the type system and calling contract. **Example:**

  ```typescript
  // ❌ Wrong: Adding impossible-to-fail checks
  const due = await db.query.budgets.findMany({
    where: and(isNotNull(budgets.budgetDuration)), // Already filtered non-null
  });
  const result = due.map(b => {
    const nextReset = computeNextResetAt(b.budgetResetAt!, b.budgetDuration!);
    if (!nextReset) { // This check is impossible to fail
      throw new Error(`Unexpected null nextResetAt`);
    }
    return nextReset;
  });

  // ✅ Right: Trust the contract
  const due = await db.query.budgets.findMany({
    where: and(isNotNull(budgets.budgetDuration)),
  });
  const result = due.map(b => computeNextResetAt(b.budgetResetAt!, b.budgetDuration!));
  ```

- **Avoid meaningless null/undefined parameters**: Don't accept null/undefined for parameters that have no business meaning when null. Design strict function contracts. **Example:**

  ```typescript
  // ❌ Wrong: Function accepts meaningless null input
  function computeNextResetAt(currentResetAt: Date, durationStr: string | null): Date | null {
    if (!durationStr) return null; // Why accept null if it just returns null?
  }

  // ✅ Right: Strict contract, clear responsibility
  function computeNextResetAt(currentResetAt: Date, durationStr: string): Date {
    // Function has single clear purpose, caller ensures valid input
  }
  ```

## Imports and Modules

- When importing a directory module, prefer the explicit index path like `@/db/index` instead of `@/db`.

## Asynchronous Patterns and Concurrency

- Prefer `async`/`await` over callbacks or chained `.then` promises.
- Prefer async APIs over sync ones (avoid `*Sync`).
- Prefer promise-based variants (e.g., `import { readFile } from 'fs/promises'`) over callback-based APIs from `fs`.
- Where safe, convert sequential async flows to concurrent ones with `Promise.all`, `Promise.race`, etc.

## Code Structure and Readability

- Refactor repeated logic into reusable functions.
- Prefer object destructuring when accessing and using properties.
- Use consistent, descriptive naming; avoid obscure abbreviations.
- Use semantically meaningful variable, function, and class names.
- Replace magic numbers or strings with well-named constants.
- Keep meaningful code comments; do not remove them when applying edits. Update comments when behavior changes.
- Ensure JSDoc comments accurately reflect the implementation.
- Look for opportunities to simplify or modernize code with the latest JavaScript/TypeScript features where it improves clarity.
- Defer formatting to tooling; ignore purely formatting-only issues and autofixable lint problems.
- Respect project Prettier settings.

## UI and Theming

- Use components from `@lobehub/ui`, Ant Design, or existing design system components instead of raw HTML tags (e.g., `Button` vs. `button`).
- Design for dark mode and mobile responsiveness:
  - Use the `antd-style` token system instead of hard-coded colors.
  - Select appropriate component variants.

## Performance

- Prefer `for…of` loops to index-based `for` loops when feasible.
- Decide whether callbacks should be debounced or throttled based on UX and performance needs.
- Reuse existing npm packages rather than reinventing the wheel (e.g., `lodash-es/omit`).
- Query only the required columns from a database rather than selecting entire rows.

## Time and Consistency

- Instead of calling `Date.now()` multiple times, assign it to a constant once and reuse it to ensure consistency and improve readability.

## Some logging rules

- Never log user private information like api key, etc
- Don't use `import { log } from 'debug'` to log messages, because it will directly log the message to the console.
